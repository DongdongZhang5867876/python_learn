<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="e7e86574-74ef-450b-9aae-6618ad2abcaa" name="Default Changelist" comment="闭包函数&#10;一 函数嵌套&#10;1. 函数嵌套调用&#10;函数嵌套调用指的是在函数内部又调用了其他的函数。&#10;&#10;#  求三个数的最大值&#10;def max2(x, y):&#10;    if x &gt; y:&#10;        return x&#10;    else:&#10;        return y&#10;&#10;&#10;def max3(x, y, z):&#10;    res1 = max2(x, y)&#10;    res2 = max2(res1, z)&#10;    return res2&#10;&#10;&#10;print(max3(11, 199, 2))&#10;2. 函数嵌套定义&#10;函数的嵌套定义指的是在函数内又定义了其他函数。&#10;&#10;# 示例1&#10;def func1():&#10;    print('from func1')&#10;&#10;    def func2():  # 定一个一个函数和定义一个变量类似&#10;        print('from func2')&#10;&#10;    print(func2)&#10;    func2()&#10;&#10;&#10;func1()&#10;# print(func2)&#10;&#10;&#10;# 示例2&#10;# 函数在定义阶段不执行函数体内的代码&#10;def f1():&#10;    print('f1')&#10;&#10;    def f2():&#10;        print('f2')&#10;&#10;        def f3():&#10;            print('f3')&#10;&#10;        f3()&#10;&#10;    f2()&#10;&#10;&#10;f1()&#10;二 名称空间&#10;1. 名称空间说明&#10;名称空间从字面意思理解是存放名字的地方，最开始我们在讲解变量的时候知道：定义一个变量就是开辟一块内存空间，这个内存空间存放的是变量的值，除了变量值之外，还有变量名，变量名与变量值的绑定关系这个数据要在内存中存储。变量名是名字，函数名也是名字，名称空间就是存放名字与值的绑定关系的地方。&#10;&#10;2. 名称空间的分类&#10;名称空间分为三类：&#10;&#10;内置名称空间：存放Python解释器自带的名字，在解释器启动时就生效，解释器关闭则失效。&#10;全局名称空间：文件级别的名字,在执行文件的时候生效，在文件结束或者在文件执行期间被删除则失效。有些全局名称空间可能一眼看上去不像是全局名称空间，我们只需要要记住，只要不是内置名称空间和局部名称空间，那么就是全局名称空间。&#10;局部名称空间：存放函数内定义的名字(函数的参数以及函数内的名字都存放与局部名称空间)，在函数调用时临时生效，函数结束则失效。&#10;# 内置&#10;print(print)&#10;print(len)&#10;&#10;# 以下4个都是全局&#10;&#10;x = 1  # 全局&#10;&#10;&#10;def func():  # func是全局名称空间&#10;    name = 'Albert'  # name是局部名称空间&#10;&#10;&#10;# del func  # 我们不需要自己删除&#10;&#10;&#10;if 10 &gt; 3:&#10;    y = 2  # 全局&#10;&#10;while True:&#10;    z = 5  # 全局&#10;    break&#10;&#10;&#10;# 局部&#10;def func1(x):  # 实参1传给行参x就相当于在函数内被定义 x=1，故x为局部&#10;    # x = 1&#10;    y = 2  # 局部&#10;&#10;&#10;func1(1)&#10;内置名称空间与全局名称空间的结束的生命周期基本上是一致的，程序执行结束或者文件关闭(手动强制关闭写python代码的这个文件)，内置或全局名称空间生命周期结束。局部名称空间生命周期是从函数调用开始到函数结束生命周期终止。&#10;&#10;加载顺序：内置名称空间-&gt;全局名称空间-&gt;局部名称空间&#10;查找名字：局部名称空间-&gt;全局名称空间-&gt;内置名称空间&#10;&#10;# 加载顺序很好理解，查找顺序是以当前位置为起始点&#10;&#10;len = 0  # 我们是为了测试，自己写代码千万不能覆盖内置名称空间&#10;&#10;&#10;def f1():&#10;    # len = 1&#10;&#10;    def f2():&#10;        # len = 2&#10;        print(len)&#10;&#10;    # len = 3&#10;    f2()&#10;&#10;&#10;f1()&#10;三 作用域&#10;1. 全局作用域&#10;全局作用域包含的是内置名称空间与全局名称空间的名字，它的特点是：&#10;&#10;在任何位置都能够访问的到&#10;该范围内的名字会伴随程序整个生命周期&#10;如果在局部使用全局作用域的变量，是没有问题的，但是如果是在局部修改全局作用域的变量则不能直接修改，而要使用global关键字才可以修改。&#10;&#10;global_count = 0&#10;&#10;&#10;def global_check():&#10;    print(global_count)  # 直接使用全局变量&#10;&#10;&#10;def global_modify():&#10;    global global_count  # 修改前需要先使用global&#10;    global_count += 1&#10;    print(global_count)&#10;&#10;&#10;global_check()&#10;global_modify()&#10;2. 局部作用域&#10;局部作用域包含的是局部名称空间的名字，它的特点是：&#10;&#10;只能在函数内使用&#10;调用函数时生效，调用结束失效&#10;如果在局部使用的是嵌套在函数内部的局部变量，同理，可以直接使用，而修改需要使用nonlocal关键字。&#10;&#10;def make_counter():&#10;    count = 0&#10;&#10;    def check_counter():&#10;        print(count)&#10;&#10;    check_counter()&#10;&#10;    def modify_counter():&#10;        nonlocal count&#10;        count += 1&#10;        print(count)&#10;&#10;    modify_counter()&#10;&#10;&#10;make_counter()&#10;四 函数对象&#10;1. 函数对象说明&#10;函数在Python中是第一类对象，这句话可以通俗理解为函数也是一个对象，就像是int，字符串，列表和字典一样都是对象，等讲到了面向对象我们就会对这个概念有了进一步理解，现在就可以暂时理解为函数对象可以像int或者字符串一样使用。&#10;&#10;# 1 函数可以被引用&#10;&#10;# int示例&#10;x = 1&#10;y = x&#10;&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;f = bar&#10;f()&#10;&#10;# 2 可以当中参数传入&#10;&#10;# int示例&#10;x = 1&#10;&#10;&#10;def func(a):&#10;    print(a)&#10;&#10;&#10;func(x)&#10;&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;def wrapper(func):&#10;    func()&#10;&#10;&#10;wrapper(bar)&#10;&#10;# 3 可以当中函数的返回值&#10;&#10;# int示例&#10;x = 1&#10;&#10;&#10;def foo():&#10;    return x&#10;&#10;&#10;res = foo()&#10;print(res)&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;def foo(func):&#10;    return func&#10;&#10;&#10;f = foo(bar)&#10;f()&#10;&#10;# 4 可以当中容器类型的元素&#10;&#10;# int示例&#10;z = 1&#10;l = [z, ]&#10;&#10;print(l)&#10;&#10;# 函数示例&#10;def get():&#10;    print('from get')&#10;&#10;&#10;def put():&#10;    print('from put')&#10;&#10;&#10;l1 = [get, put]&#10;&#10;l1[0]()&#10;2. 函数对象应用(重点)&#10;利用这一特性，可以优雅的取代原来的if多分支(elif这种多分支是我们写代码要尽可能避免的)。&#10;&#10;def auth():&#10;    print('登陆。。。。。')&#10;&#10;&#10;def register():&#10;    print('注册。。。。。')&#10;&#10;&#10;def check():&#10;    print('查看。。。。')&#10;&#10;&#10;def transfer():&#10;    print('转账。。。。')&#10;&#10;&#10;def pay():&#10;    print('支付。。。。')&#10;&#10;&#10;func_dict = {&#10;    '1': auth,&#10;    '2': register,&#10;    '3': check,&#10;    '4': transfer,&#10;    '5': pay&#10;}&#10;&#10;&#10;def interactive():&#10;    while True:&#10;        print(&quot;&quot;&quot;&#10;        1 登录&#10;        2 注册&#10;        3 查看&#10;        4 转账&#10;        5 支付&#10;        &quot;&quot;&quot;)&#10;        choice = input('&gt;&gt;: ').strip()&#10;        if choice in func_dict:&#10;            func_dict[choice]()&#10;        else:&#10;            print('非法操作')&#10;&#10;&#10;interactive()&#10;五 闭包函数&#10;1. 闭包函数说明&#10;闭包函数就是定义在函数内部的函数，也就是函数的嵌套定义，根据字面意思理解，闭包函数有两个关键字闭和包分别是的封闭和包裹。需要注意的重点是：闭包函数的作用域关系在函数定义阶段就固定死了，与调用位置无关。&#10;&#10;def outer():&#10;    x = 1&#10;&#10;    def inner():  # 在outer函数内部再定一个函数&#10;        # x = 2  &#10;        print('from inner', x)&#10;&#10;    return inner  # outer函数返回inner函数对象&#10;&#10;&#10;f = outer()  # 现在的f是一个全局变量，同时是inner函数对象&#10;print(f)&#10;x = 3  # 这个x = 3并不能改变inner函数外层的x&#10;f()&#10;&#10;&#10;def foo():&#10;    x = 4  # 这个x = 4 同样也不能改变&#10;    f()  # 全局作用域在任意位置都可以调用&#10;&#10;&#10;foo()&#10;闭包函数可以用外层函数来调用内部的函数，打破了函数的层级限制，与此同时该函数包含对外部函数作用域中名字的引用。&#10;&#10;def outer():&#10;    name = 'Albert'&#10;&#10;    def inner():&#10;        print('my name is %s' % name)&#10;&#10;    return inner&#10;&#10;&#10;f = outer()&#10;f()&#10;2. 为函数体传值的两种方式&#10;(1) 以参数的形式的传入&#10;# 模块的导入后面章节会讲解，requests模块就是模拟浏览器向目标站点发请求&#10;import requests&#10;&#10;&#10;def get(url):&#10;    response = requests.get(url)  # get方法获取请求返回对象&#10;    print(response)&#10;    if response.status_code == 200:  # 200是一个状态码，代表请求成功&#10;        print(response.text)  # text方法是获取返回对象的内容&#10;&#10;&#10;get('https://www.baidu.com')&#10;(2) 以闭包函数的形式传入&#10;闭包函数就是在函数外层再包裹一层作用域，由于这个作用域在外层函数内部，所以只作用在内层函数上。&#10;&#10;import requests&#10;&#10;&#10;def outer(url):  # 给外层函数穿参就相当于 url='https://www.baidu.com'&#10;&#10;    # url='https://www.baidu.com'  # 这个作用域就是作用在get函数上的&#10;    def get():&#10;        response = requests.get(url)&#10;        if response.status_code == 200:&#10;            print(response.text)&#10;&#10;    return get&#10;&#10;&#10;baidu = outer('https://www.baidu.com')&#10;python = outer('https://www.python.org')&#10;&#10;baidu()&#10;print('=================================&gt;')&#10;python()&#10;简化与总结闭包函数用法&#10;&#10;def outer(x):&#10;    def foo():  # foo虽然没有直接传参，但是outer函数的作用域赋予了x动态变化&#10;        print(x)&#10;&#10;    return foo&#10;&#10;&#10;f_10 = outer(10)&#10;&#10;f_10()&#10;&#10;f_100 = outer(100)&#10;f_100()&#10;六 装饰器&#10;1. 装饰器说明&#10;器指的工具(只要是工具，你就应该想到函数)，装饰指的是为被装饰对象添加新功能，需要注意的是：项目一旦上线之后，就应该遵循开发封闭的原则。开放封闭指的是对修改函数内的源代码和调用方式是封闭的，对功能的扩展是开放的。看起来有点矛盾，但这就是我们要做的。在这样的要求下，我们必须要找到一种解决方案，能够在不修改一个功能内源代码以及调用方式的前提下，为其添加新功能。这就用到了装饰器，它能够在不修改被装饰对象源代码与调用方式的前提下，为被装饰器对象添加新功能。&#10;&#10;2. 无参装饰器&#10;(1) 无参装饰器实现过程&#10;无参装饰器指的是装饰器本身没有参数。&#10;&#10;# 要求：为index函数添加一个统计时间的功能&#10;import time  # 这是一个与时间相关的模块&#10;&#10;&#10;def index():&#10;    time.sleep(3)  # 睡3秒&#10;    print('welcome to index page')&#10;&#10;&#10;index()&#10;&#10;# 版本一(只有index函数可以使用)&#10;import time  # 这是一个与时间相关的模块&#10;&#10;&#10;def index():&#10;    time.sleep(3)  # 睡3秒&#10;    print('welcome to index page')&#10;&#10;&#10;start_time = time.time()  # 从1970年开始计时的时间戳&#10;index()&#10;end_time = time.time()&#10;print('run time is %s' % (end_time - start_time))&#10;&#10;&#10;# 版本二(两个函数都可以使用，但是有大量重复代码)&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def home(name):&#10;    time.sleep(5)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;start_time = time.time()&#10;index()&#10;stop_time = time.time()&#10;print('run time is %s' % (stop_time - start_time))&#10;&#10;start_time = time.time()&#10;home('Albert')&#10;stop_time = time.time()&#10;print('run time is %s' % (stop_time - start_time))&#10;&#10;# 版本三(修改了源函数的调用方式)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def home(name):&#10;    time.sleep(5)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;def wrapper(func):  # func=index&#10;    start_time = time.time()&#10;    func()  # index()&#10;    stop_time = time.time()&#10;    print('run time is %s' % (stop_time - start_time))&#10;&#10;&#10;wrapper(index)&#10;&#10;# 版本四(使用闭包函数，不修改源函数调用方式)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def outer(func):  # func=最原始的index&#10;    # func=最原始的index&#10;    def wrapper():&#10;        start_time = time.time()&#10;        func()&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;&#10;    return wrapper&#10;&#10;&#10;# a = outer(index)  # outer函数结果可以赋值给任意变量&#10;# b = outer(index)&#10;# c = outer(index)&#10;&#10;index = outer(index)  # 赋值给index覆盖原来的index，index = wrapper&#10;&#10;index()  # wrapper()&#10;&#10;# 版本五(解决原函数返回值无效)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1  # 假如源函数有一个返回值&#10;&#10;&#10;def outer(func):&#10;    # func=最原始的home&#10;    def wrapper():&#10;        start_time = time.time()&#10;        res = func()  # 调用最原始的index&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;index = outer(index)  # 新的index=wrapper&#10;res = index()  # 上一个版本返回值为None&#10;print(res)&#10;&#10;# 版本六(终极版，解决有参函数和无参函数通用的问题)&#10;&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;def timer(func):  # 装饰器也是一个函数，我们给他一个好听的名字&#10;    def wrapper(*args, **kwargs):  # wrapper函数有无参数由源函数决定&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;index = timer(index)  # 新的index=wrapper&#10;home = timer(home)  # 新的home=wrapper&#10;&#10;home(name='Albert')  # wrapper(name='Albert')&#10;home('Albert')  # wrapper('Albert')&#10;index()  # wrapper()&#10;&#10;&#10;# 无参装饰器模板&#10;def outer(func):&#10;    def inner(*args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        这里写装饰器逻辑&#10;        :param args: 任意位置参数&#10;        :param kwargs: 任意关键参数&#10;        :return: 一个函数对象&#10;        &quot;&quot;&quot;&#10;        res = func(*args, **kwargs)&#10;        return res&#10;&#10;    return inner&#10;(2) 装饰器语法糖&#10;import time&#10;&#10;&#10;# 装饰器也是一个函数，使用函数必先定义，所以装饰器放在最上方&#10;def timer(func):&#10;    def wrapper(*args, **kwargs):&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;@timer  # 在被装饰对象正上方单独一行添加，相当于执行index=timer(index)&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;# @timer  # home=timer(home) 当不需要装饰器的时候只需注释这一行即可&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;index()&#10;home('Albert')&#10;(3) 用户认证装饰器&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(func):&#10;    def wrapper(*args, **kwargs):&#10;        if current_user['username']:&#10;            print('已经登陆过了')&#10;            res = func(*args, **kwargs)&#10;            return res&#10;&#10;        name = input('用户名&gt;&gt;: ').strip()&#10;        pwd = input('密码&gt;&gt;: ').strip()&#10;        if name == 'Albert' and pwd == '1':&#10;            print('登陆成功')&#10;            current_user['username'] = name&#10;            res = func(*args, **kwargs)&#10;            return res&#10;        else:&#10;            print('用户名或密码错误')&#10;&#10;    return wrapper&#10;&#10;&#10;@auth&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;@auth&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;index()&#10;home('Albert')&#10;(3) 多个装饰器叠加&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(func):&#10;    def wrapper(*args, **kwargs):&#10;        if current_user['username']:&#10;            print('已经登陆过了')&#10;            res = func(*args, **kwargs)&#10;            return res&#10;&#10;        name = input('用户名&gt;&gt;: ').strip()&#10;        pwd = input('密码&gt;&gt;: ').strip()&#10;        if name == 'Albert' and pwd == '1':&#10;            print('登陆成功')&#10;            current_user['username'] = name&#10;            res = func(*args, **kwargs)&#10;            return res&#10;        else:&#10;            print('用户名或密码错误')&#10;&#10;    return wrapper&#10;&#10;&#10;def timer(func):&#10;    def wrapper(*args, **kwargs):&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;&quot;&quot;&quot;&#10;@auth  &#10;@timer  # 这样写的话timer只统计index的执行时间&#10;&quot;&quot;&quot;&#10;&#10;&#10;@timer  # timer 统计的是auth+index的执行时间&#10;@auth&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;index()&#10;3. 有参装饰器&#10;有参装饰器就是装饰器本身需要一个参数，结合我们以前讲过的文件操作，其实文件就是存放数据的仓库，类似于数据库，数据库分很多种，常见的有MySQL，Oracle，PostgreSQL和DB2等等，在一些项目的需求中，不同的数据会分散存储在不同的数据库中，这时我们使用基于对象的数据模型(通俗讲就是使用编程语言来操作数据库)操作不同数据库就要执行不同的代码。&#10;&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(engine):&#10;    def user_auth(func):&#10;        def wrapper(*args, **kwargs):&#10;            if engine == 'file':&#10;                print('基于文件的认证')&#10;                if current_user['username']:&#10;                    print('已经登陆过了')&#10;                    res = func(*args, **kwargs)&#10;                    return res&#10;&#10;                name = input('用户名&gt;&gt;: ').strip()&#10;                pwd = input('密码&gt;&gt;: ').strip()&#10;                if name == 'Albert' and pwd == '1':&#10;                    print('登陆成功')&#10;                    current_user['username'] = name&#10;                    res = func(*args, **kwargs)&#10;                    return res&#10;                else:&#10;                    print('用户名或密码错误')&#10;            elif engine == 'mysql':&#10;                print('基于MyQL的认证')&#10;            elif engine == 'ldap':&#10;                print('基于LDAP的认证')&#10;            elif engine == 'postgresql':&#10;                print('基于PostgreSQL的认证')&#10;&#10;        return wrapper&#10;&#10;    return user_auth&#10;&#10;&#10;@auth('file')  # auth装饰器本身是一个函数，在语法糖中也可以传参数&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;index()&#10;4. 装饰器补充&#10;from functools import wraps&#10;&#10;&#10;def deco(func):&#10;    @wraps(func)  # 加在最内层函数正上方&#10;    def wrapper(*args, **kwargs):&#10;        return func(*args, **kwargs)&#10;&#10;    return wrapper&#10;&#10;&#10;@deco&#10;def index():&#10;    '''哈哈哈哈'''&#10;    print('from index')&#10;装饰器使用的是闭包函数的原理，返回的是和原来函数同名字的函数地址，再加上()就能调用这个函数，所以给我们的感觉是原来的函数没有变化，却添加了新的功能，其实已经不是原来的函数了，你可以把以上代码的第三行注释掉，运行代码，打印结果为None，就是因为你运行的函数已经不是原来的函数了，所以这其实是一个伪装饰器，要想让装饰器真的是装饰器，调用别人写好的包，返回结果还是原函数，以上写法就是。">
      <change afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/modules.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/python_learn.iml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/Day_09/Day_09.py" beforeDir="false" afterPath="$PROJECT_DIR$/Day_09/Day_09.py" afterDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf>
      <file pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/Day_09/Day_09.py">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="142">
              <caret line="140" column="8" selection-start-line="140" selection-start-column="8" selection-end-line="140" selection-end-column="34" />
            </state>
          </provider>
        </entry>
      </file>
      <file pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/Day_09/have a try.py">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="76">
              <caret line="5" selection-start-line="5" selection-end-line="26" selection-end-column="14" />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Python Script" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/Day_09/have a try.py" />
        <option value="$PROJECT_DIR$/Day_09/Day_09.py" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds" extendedState="1">
    <option name="x" value="676" />
    <option name="width" value="697" />
    <option name="height" value="735" />
  </component>
  <component name="ProjectView">
    <navigator proportions="" version="1">
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="python_learn" type="b2602c69:ProjectViewProjectNode" />
              <item name="python_learn" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="python_learn" type="b2602c69:ProjectViewProjectNode" />
              <item name="python_learn" type="462c0819:PsiDirectoryNode" />
              <item name="Day_09" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="ASKED_SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="nodejs_interpreter_path.stuck_in_default_project" value="undefined stuck path" />
    <property name="nodejs_npm_path_reset_for_default_project" value="true" />
  </component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Python.Day_09">
    <configuration name="Day_09" type="PythonConfigurationType" factoryName="Python" temporary="true">
      <module name="python_learn" />
      <option name="INTERPRETER_OPTIONS" value="" />
      <option name="PARENT_ENVS" value="true" />
      <envs>
        <env name="PYTHONUNBUFFERED" value="1" />
      </envs>
      <option name="SDK_HOME" value="" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Day_09" />
      <option name="IS_MODULE_SDK" value="true" />
      <option name="ADD_CONTENT_ROOTS" value="true" />
      <option name="ADD_SOURCE_ROOTS" value="true" />
      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Day_09/Day_09.py" />
      <option name="PARAMETERS" value="" />
      <option name="SHOW_COMMAND_LINE" value="false" />
      <option name="EMULATE_TERMINAL" value="false" />
      <option name="MODULE_MODE" value="false" />
      <option name="REDIRECT_INPUT" value="false" />
      <option name="INPUT_FILE" value="" />
      <method v="2" />
    </configuration>
    <configuration name="have a try" type="PythonConfigurationType" factoryName="Python" temporary="true">
      <module name="python_learn" />
      <option name="INTERPRETER_OPTIONS" value="" />
      <option name="PARENT_ENVS" value="true" />
      <envs>
        <env name="PYTHONUNBUFFERED" value="1" />
      </envs>
      <option name="SDK_HOME" value="" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Day_09" />
      <option name="IS_MODULE_SDK" value="true" />
      <option name="ADD_CONTENT_ROOTS" value="true" />
      <option name="ADD_SOURCE_ROOTS" value="true" />
      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Day_09/have a try.py" />
      <option name="PARAMETERS" value="" />
      <option name="SHOW_COMMAND_LINE" value="false" />
      <option name="EMULATE_TERMINAL" value="false" />
      <option name="MODULE_MODE" value="false" />
      <option name="REDIRECT_INPUT" value="false" />
      <option name="INPUT_FILE" value="" />
      <method v="2" />
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Python.Day_09" />
        <item itemvalue="Python.have a try" />
      </list>
    </recent_temporary>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="e7e86574-74ef-450b-9aae-6618ad2abcaa" name="Default Changelist" comment="" />
      <created>1555726981010</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1555726981010</updated>
      <workItem from="1555726982932" duration="13580000" />
    </task>
    <task id="LOCAL-00001" summary="闭包函数&#10;一 函数嵌套&#10;1. 函数嵌套调用&#10;函数嵌套调用指的是在函数内部又调用了其他的函数。&#10;&#10;#  求三个数的最大值&#10;def max2(x, y):&#10;    if x &gt; y:&#10;        return x&#10;    else:&#10;        return y&#10;&#10;&#10;def max3(x, y, z):&#10;    res1 = max2(x, y)&#10;    res2 = max2(res1, z)&#10;    return res2&#10;&#10;&#10;print(max3(11, 199, 2))&#10;2. 函数嵌套定义&#10;函数的嵌套定义指的是在函数内又定义了其他函数。&#10;&#10;# 示例1&#10;def func1():&#10;    print('from func1')&#10;&#10;    def func2():  # 定一个一个函数和定义一个变量类似&#10;        print('from func2')&#10;&#10;    print(func2)&#10;    func2()&#10;&#10;&#10;func1()&#10;# print(func2)&#10;&#10;&#10;# 示例2&#10;# 函数在定义阶段不执行函数体内的代码&#10;def f1():&#10;    print('f1')&#10;&#10;    def f2():&#10;        print('f2')&#10;&#10;        def f3():&#10;            print('f3')&#10;&#10;        f3()&#10;&#10;    f2()&#10;&#10;&#10;f1()&#10;二 名称空间&#10;1. 名称空间说明&#10;名称空间从字面意思理解是存放名字的地方，最开始我们在讲解变量的时候知道：定义一个变量就是开辟一块内存空间，这个内存空间存放的是变量的值，除了变量值之外，还有变量名，变量名与变量值的绑定关系这个数据要在内存中存储。变量名是名字，函数名也是名字，名称空间就是存放名字与值的绑定关系的地方。&#10;&#10;2. 名称空间的分类&#10;名称空间分为三类：&#10;&#10;内置名称空间：存放Python解释器自带的名字，在解释器启动时就生效，解释器关闭则失效。&#10;全局名称空间：文件级别的名字,在执行文件的时候生效，在文件结束或者在文件执行期间被删除则失效。有些全局名称空间可能一眼看上去不像是全局名称空间，我们只需要要记住，只要不是内置名称空间和局部名称空间，那么就是全局名称空间。&#10;局部名称空间：存放函数内定义的名字(函数的参数以及函数内的名字都存放与局部名称空间)，在函数调用时临时生效，函数结束则失效。&#10;# 内置&#10;print(print)&#10;print(len)&#10;&#10;# 以下4个都是全局&#10;&#10;x = 1  # 全局&#10;&#10;&#10;def func():  # func是全局名称空间&#10;    name = 'Albert'  # name是局部名称空间&#10;&#10;&#10;# del func  # 我们不需要自己删除&#10;&#10;&#10;if 10 &gt; 3:&#10;    y = 2  # 全局&#10;&#10;while True:&#10;    z = 5  # 全局&#10;    break&#10;&#10;&#10;# 局部&#10;def func1(x):  # 实参1传给行参x就相当于在函数内被定义 x=1，故x为局部&#10;    # x = 1&#10;    y = 2  # 局部&#10;&#10;&#10;func1(1)&#10;内置名称空间与全局名称空间的结束的生命周期基本上是一致的，程序执行结束或者文件关闭(手动强制关闭写python代码的这个文件)，内置或全局名称空间生命周期结束。局部名称空间生命周期是从函数调用开始到函数结束生命周期终止。&#10;&#10;加载顺序：内置名称空间-&gt;全局名称空间-&gt;局部名称空间&#10;查找名字：局部名称空间-&gt;全局名称空间-&gt;内置名称空间&#10;&#10;# 加载顺序很好理解，查找顺序是以当前位置为起始点&#10;&#10;len = 0  # 我们是为了测试，自己写代码千万不能覆盖内置名称空间&#10;&#10;&#10;def f1():&#10;    # len = 1&#10;&#10;    def f2():&#10;        # len = 2&#10;        print(len)&#10;&#10;    # len = 3&#10;    f2()&#10;&#10;&#10;f1()&#10;三 作用域&#10;1. 全局作用域&#10;全局作用域包含的是内置名称空间与全局名称空间的名字，它的特点是：&#10;&#10;在任何位置都能够访问的到&#10;该范围内的名字会伴随程序整个生命周期&#10;如果在局部使用全局作用域的变量，是没有问题的，但是如果是在局部修改全局作用域的变量则不能直接修改，而要使用global关键字才可以修改。&#10;&#10;global_count = 0&#10;&#10;&#10;def global_check():&#10;    print(global_count)  # 直接使用全局变量&#10;&#10;&#10;def global_modify():&#10;    global global_count  # 修改前需要先使用global&#10;    global_count += 1&#10;    print(global_count)&#10;&#10;&#10;global_check()&#10;global_modify()&#10;2. 局部作用域&#10;局部作用域包含的是局部名称空间的名字，它的特点是：&#10;&#10;只能在函数内使用&#10;调用函数时生效，调用结束失效&#10;如果在局部使用的是嵌套在函数内部的局部变量，同理，可以直接使用，而修改需要使用nonlocal关键字。&#10;&#10;def make_counter():&#10;    count = 0&#10;&#10;    def check_counter():&#10;        print(count)&#10;&#10;    check_counter()&#10;&#10;    def modify_counter():&#10;        nonlocal count&#10;        count += 1&#10;        print(count)&#10;&#10;    modify_counter()&#10;&#10;&#10;make_counter()&#10;四 函数对象&#10;1. 函数对象说明&#10;函数在Python中是第一类对象，这句话可以通俗理解为函数也是一个对象，就像是int，字符串，列表和字典一样都是对象，等讲到了面向对象我们就会对这个概念有了进一步理解，现在就可以暂时理解为函数对象可以像int或者字符串一样使用。&#10;&#10;# 1 函数可以被引用&#10;&#10;# int示例&#10;x = 1&#10;y = x&#10;&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;f = bar&#10;f()&#10;&#10;# 2 可以当中参数传入&#10;&#10;# int示例&#10;x = 1&#10;&#10;&#10;def func(a):&#10;    print(a)&#10;&#10;&#10;func(x)&#10;&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;def wrapper(func):&#10;    func()&#10;&#10;&#10;wrapper(bar)&#10;&#10;# 3 可以当中函数的返回值&#10;&#10;# int示例&#10;x = 1&#10;&#10;&#10;def foo():&#10;    return x&#10;&#10;&#10;res = foo()&#10;print(res)&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;def foo(func):&#10;    return func&#10;&#10;&#10;f = foo(bar)&#10;f()&#10;&#10;# 4 可以当中容器类型的元素&#10;&#10;# int示例&#10;z = 1&#10;l = [z, ]&#10;&#10;print(l)&#10;&#10;# 函数示例&#10;def get():&#10;    print('from get')&#10;&#10;&#10;def put():&#10;    print('from put')&#10;&#10;&#10;l1 = [get, put]&#10;&#10;l1[0]()&#10;2. 函数对象应用(重点)&#10;利用这一特性，可以优雅的取代原来的if多分支(elif这种多分支是我们写代码要尽可能避免的)。&#10;&#10;def auth():&#10;    print('登陆。。。。。')&#10;&#10;&#10;def register():&#10;    print('注册。。。。。')&#10;&#10;&#10;def check():&#10;    print('查看。。。。')&#10;&#10;&#10;def transfer():&#10;    print('转账。。。。')&#10;&#10;&#10;def pay():&#10;    print('支付。。。。')&#10;&#10;&#10;func_dict = {&#10;    '1': auth,&#10;    '2': register,&#10;    '3': check,&#10;    '4': transfer,&#10;    '5': pay&#10;}&#10;&#10;&#10;def interactive():&#10;    while True:&#10;        print(&quot;&quot;&quot;&#10;        1 登录&#10;        2 注册&#10;        3 查看&#10;        4 转账&#10;        5 支付&#10;        &quot;&quot;&quot;)&#10;        choice = input('&gt;&gt;: ').strip()&#10;        if choice in func_dict:&#10;            func_dict[choice]()&#10;        else:&#10;            print('非法操作')&#10;&#10;&#10;interactive()&#10;五 闭包函数&#10;1. 闭包函数说明&#10;闭包函数就是定义在函数内部的函数，也就是函数的嵌套定义，根据字面意思理解，闭包函数有两个关键字闭和包分别是的封闭和包裹。需要注意的重点是：闭包函数的作用域关系在函数定义阶段就固定死了，与调用位置无关。&#10;&#10;def outer():&#10;    x = 1&#10;&#10;    def inner():  # 在outer函数内部再定一个函数&#10;        # x = 2  &#10;        print('from inner', x)&#10;&#10;    return inner  # outer函数返回inner函数对象&#10;&#10;&#10;f = outer()  # 现在的f是一个全局变量，同时是inner函数对象&#10;print(f)&#10;x = 3  # 这个x = 3并不能改变inner函数外层的x&#10;f()&#10;&#10;&#10;def foo():&#10;    x = 4  # 这个x = 4 同样也不能改变&#10;    f()  # 全局作用域在任意位置都可以调用&#10;&#10;&#10;foo()&#10;闭包函数可以用外层函数来调用内部的函数，打破了函数的层级限制，与此同时该函数包含对外部函数作用域中名字的引用。&#10;&#10;def outer():&#10;    name = 'Albert'&#10;&#10;    def inner():&#10;        print('my name is %s' % name)&#10;&#10;    return inner&#10;&#10;&#10;f = outer()&#10;f()&#10;2. 为函数体传值的两种方式&#10;(1) 以参数的形式的传入&#10;# 模块的导入后面章节会讲解，requests模块就是模拟浏览器向目标站点发请求&#10;import requests&#10;&#10;&#10;def get(url):&#10;    response = requests.get(url)  # get方法获取请求返回对象&#10;    print(response)&#10;    if response.status_code == 200:  # 200是一个状态码，代表请求成功&#10;        print(response.text)  # text方法是获取返回对象的内容&#10;&#10;&#10;get('https://www.baidu.com')&#10;(2) 以闭包函数的形式传入&#10;闭包函数就是在函数外层再包裹一层作用域，由于这个作用域在外层函数内部，所以只作用在内层函数上。&#10;&#10;import requests&#10;&#10;&#10;def outer(url):  # 给外层函数穿参就相当于 url='https://www.baidu.com'&#10;&#10;    # url='https://www.baidu.com'  # 这个作用域就是作用在get函数上的&#10;    def get():&#10;        response = requests.get(url)&#10;        if response.status_code == 200:&#10;            print(response.text)&#10;&#10;    return get&#10;&#10;&#10;baidu = outer('https://www.baidu.com')&#10;python = outer('https://www.python.org')&#10;&#10;baidu()&#10;print('=================================&gt;')&#10;python()&#10;简化与总结闭包函数用法&#10;&#10;def outer(x):&#10;    def foo():  # foo虽然没有直接传参，但是outer函数的作用域赋予了x动态变化&#10;        print(x)&#10;&#10;    return foo&#10;&#10;&#10;f_10 = outer(10)&#10;&#10;f_10()&#10;&#10;f_100 = outer(100)&#10;f_100()&#10;六 装饰器&#10;1. 装饰器说明&#10;器指的工具(只要是工具，你就应该想到函数)，装饰指的是为被装饰对象添加新功能，需要注意的是：项目一旦上线之后，就应该遵循开发封闭的原则。开放封闭指的是对修改函数内的源代码和调用方式是封闭的，对功能的扩展是开放的。看起来有点矛盾，但这就是我们要做的。在这样的要求下，我们必须要找到一种解决方案，能够在不修改一个功能内源代码以及调用方式的前提下，为其添加新功能。这就用到了装饰器，它能够在不修改被装饰对象源代码与调用方式的前提下，为被装饰器对象添加新功能。&#10;&#10;2. 无参装饰器&#10;(1) 无参装饰器实现过程&#10;无参装饰器指的是装饰器本身没有参数。&#10;&#10;# 要求：为index函数添加一个统计时间的功能&#10;import time  # 这是一个与时间相关的模块&#10;&#10;&#10;def index():&#10;    time.sleep(3)  # 睡3秒&#10;    print('welcome to index page')&#10;&#10;&#10;index()&#10;&#10;# 版本一(只有index函数可以使用)&#10;import time  # 这是一个与时间相关的模块&#10;&#10;&#10;def index():&#10;    time.sleep(3)  # 睡3秒&#10;    print('welcome to index page')&#10;&#10;&#10;start_time = time.time()  # 从1970年开始计时的时间戳&#10;index()&#10;end_time = time.time()&#10;print('run time is %s' % (end_time - start_time))&#10;&#10;&#10;# 版本二(两个函数都可以使用，但是有大量重复代码)&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def home(name):&#10;    time.sleep(5)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;start_time = time.time()&#10;index()&#10;stop_time = time.time()&#10;print('run time is %s' % (stop_time - start_time))&#10;&#10;start_time = time.time()&#10;home('Albert')&#10;stop_time = time.time()&#10;print('run time is %s' % (stop_time - start_time))&#10;&#10;# 版本三(修改了源函数的调用方式)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def home(name):&#10;    time.sleep(5)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;def wrapper(func):  # func=index&#10;    start_time = time.time()&#10;    func()  # index()&#10;    stop_time = time.time()&#10;    print('run time is %s' % (stop_time - start_time))&#10;&#10;&#10;wrapper(index)&#10;&#10;# 版本四(使用闭包函数，不修改源函数调用方式)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def outer(func):  # func=最原始的index&#10;    # func=最原始的index&#10;    def wrapper():&#10;        start_time = time.time()&#10;        func()&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;&#10;    return wrapper&#10;&#10;&#10;# a = outer(index)  # outer函数结果可以赋值给任意变量&#10;# b = outer(index)&#10;# c = outer(index)&#10;&#10;index = outer(index)  # 赋值给index覆盖原来的index，index = wrapper&#10;&#10;index()  # wrapper()&#10;&#10;# 版本五(解决原函数返回值无效)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1  # 假如源函数有一个返回值&#10;&#10;&#10;def outer(func):&#10;    # func=最原始的home&#10;    def wrapper():&#10;        start_time = time.time()&#10;        res = func()  # 调用最原始的index&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;index = outer(index)  # 新的index=wrapper&#10;res = index()  # 上一个版本返回值为None&#10;print(res)&#10;&#10;# 版本六(终极版，解决有参函数和无参函数通用的问题)&#10;&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;def timer(func):  # 装饰器也是一个函数，我们给他一个好听的名字&#10;    def wrapper(*args, **kwargs):  # wrapper函数有无参数由源函数决定&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;index = timer(index)  # 新的index=wrapper&#10;home = timer(home)  # 新的home=wrapper&#10;&#10;home(name='Albert')  # wrapper(name='Albert')&#10;home('Albert')  # wrapper('Albert')&#10;index()  # wrapper()&#10;&#10;&#10;# 无参装饰器模板&#10;def outer(func):&#10;    def inner(*args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        这里写装饰器逻辑&#10;        :param args: 任意位置参数&#10;        :param kwargs: 任意关键参数&#10;        :return: 一个函数对象&#10;        &quot;&quot;&quot;&#10;        res = func(*args, **kwargs)&#10;        return res&#10;&#10;    return inner&#10;(2) 装饰器语法糖&#10;import time&#10;&#10;&#10;# 装饰器也是一个函数，使用函数必先定义，所以装饰器放在最上方&#10;def timer(func):&#10;    def wrapper(*args, **kwargs):&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;@timer  # 在被装饰对象正上方单独一行添加，相当于执行index=timer(index)&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;# @timer  # home=timer(home) 当不需要装饰器的时候只需注释这一行即可&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;index()&#10;home('Albert')&#10;(3) 用户认证装饰器&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(func):&#10;    def wrapper(*args, **kwargs):&#10;        if current_user['username']:&#10;            print('已经登陆过了')&#10;            res = func(*args, **kwargs)&#10;            return res&#10;&#10;        name = input('用户名&gt;&gt;: ').strip()&#10;        pwd = input('密码&gt;&gt;: ').strip()&#10;        if name == 'Albert' and pwd == '1':&#10;            print('登陆成功')&#10;            current_user['username'] = name&#10;            res = func(*args, **kwargs)&#10;            return res&#10;        else:&#10;            print('用户名或密码错误')&#10;&#10;    return wrapper&#10;&#10;&#10;@auth&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;@auth&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;index()&#10;home('Albert')&#10;(3) 多个装饰器叠加&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(func):&#10;    def wrapper(*args, **kwargs):&#10;        if current_user['username']:&#10;            print('已经登陆过了')&#10;            res = func(*args, **kwargs)&#10;            return res&#10;&#10;        name = input('用户名&gt;&gt;: ').strip()&#10;        pwd = input('密码&gt;&gt;: ').strip()&#10;        if name == 'Albert' and pwd == '1':&#10;            print('登陆成功')&#10;            current_user['username'] = name&#10;            res = func(*args, **kwargs)&#10;            return res&#10;        else:&#10;            print('用户名或密码错误')&#10;&#10;    return wrapper&#10;&#10;&#10;def timer(func):&#10;    def wrapper(*args, **kwargs):&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;&quot;&quot;&quot;&#10;@auth  &#10;@timer  # 这样写的话timer只统计index的执行时间&#10;&quot;&quot;&quot;&#10;&#10;&#10;@timer  # timer 统计的是auth+index的执行时间&#10;@auth&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;index()&#10;3. 有参装饰器&#10;有参装饰器就是装饰器本身需要一个参数，结合我们以前讲过的文件操作，其实文件就是存放数据的仓库，类似于数据库，数据库分很多种，常见的有MySQL，Oracle，PostgreSQL和DB2等等，在一些项目的需求中，不同的数据会分散存储在不同的数据库中，这时我们使用基于对象的数据模型(通俗讲就是使用编程语言来操作数据库)操作不同数据库就要执行不同的代码。&#10;&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(engine):&#10;    def user_auth(func):&#10;        def wrapper(*args, **kwargs):&#10;            if engine == 'file':&#10;                print('基于文件的认证')&#10;                if current_user['username']:&#10;                    print('已经登陆过了')&#10;                    res = func(*args, **kwargs)&#10;                    return res&#10;&#10;                name = input('用户名&gt;&gt;: ').strip()&#10;                pwd = input('密码&gt;&gt;: ').strip()&#10;                if name == 'Albert' and pwd == '1':&#10;                    print('登陆成功')&#10;                    current_user['username'] = name&#10;                    res = func(*args, **kwargs)&#10;                    return res&#10;                else:&#10;                    print('用户名或密码错误')&#10;            elif engine == 'mysql':&#10;                print('基于MyQL的认证')&#10;            elif engine == 'ldap':&#10;                print('基于LDAP的认证')&#10;            elif engine == 'postgresql':&#10;                print('基于PostgreSQL的认证')&#10;&#10;        return wrapper&#10;&#10;    return user_auth&#10;&#10;&#10;@auth('file')  # auth装饰器本身是一个函数，在语法糖中也可以传参数&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;index()&#10;4. 装饰器补充&#10;from functools import wraps&#10;&#10;&#10;def deco(func):&#10;    @wraps(func)  # 加在最内层函数正上方&#10;    def wrapper(*args, **kwargs):&#10;        return func(*args, **kwargs)&#10;&#10;    return wrapper&#10;&#10;&#10;@deco&#10;def index():&#10;    '''哈哈哈哈'''&#10;    print('from index')&#10;装饰器使用的是闭包函数的原理，返回的是和原来函数同名字的函数地址，再加上()就能调用这个函数，所以给我们的感觉是原来的函数没有变化，却添加了新的功能，其实已经不是原来的函数了，你可以把以上代码的第三行注释掉，运行代码，打印结果为None，就是因为你运行的函数已经不是原来的函数了，所以这其实是一个伪装饰器，要想让装饰器真的是装饰器，调用别人写好的包，返回结果还是原函数，以上写法就是。">
      <created>1555727191967</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1555727191967</updated>
    </task>
    <option name="localTasksCounter" value="2" />
    <servers />
  </component>
  <component name="TimeTrackingManager">
    <option name="totallyTimeSpent" value="13580000" />
  </component>
  <component name="ToolWindowManager">
    <frame x="676" y="0" width="697" height="735" extended-state="1" />
    <editor active="true" />
    <layout>
      <window_info id="Favorites" side_tool="true" />
      <window_info content_ui="combo" id="Project" order="0" weight="0.24960753" />
      <window_info id="Structure" order="1" side_tool="true" weight="0.25" />
      <window_info anchor="bottom" id="Docker" show_stripe_button="false" />
      <window_info anchor="bottom" id="Database Changes" />
      <window_info anchor="bottom" id="Version Control" />
      <window_info anchor="bottom" id="Python Console" />
      <window_info anchor="bottom" id="Terminal" />
      <window_info anchor="bottom" id="Event Log" side_tool="true" />
      <window_info anchor="bottom" id="Message" order="0" />
      <window_info anchor="bottom" id="Find" order="1" />
      <window_info active="true" anchor="bottom" id="Run" order="2" visible="true" weight="0.18302828" />
      <window_info anchor="bottom" id="Debug" order="3" weight="0.4" />
      <window_info anchor="bottom" id="Cvs" order="4" weight="0.25" />
      <window_info anchor="bottom" id="Inspection" order="5" weight="0.4" />
      <window_info anchor="bottom" id="TODO" order="6" />
      <window_info anchor="right" id="SciView" />
      <window_info anchor="right" id="Database" />
      <window_info anchor="right" id="Commander" internal_type="SLIDING" order="0" type="SLIDING" weight="0.4" />
      <window_info anchor="right" id="Ant Build" order="1" weight="0.25" />
      <window_info anchor="right" content_ui="combo" id="Hierarchy" order="2" weight="0.25" />
    </layout>
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="闭包函数&#10;一 函数嵌套&#10;1. 函数嵌套调用&#10;函数嵌套调用指的是在函数内部又调用了其他的函数。&#10;&#10;#  求三个数的最大值&#10;def max2(x, y):&#10;    if x &gt; y:&#10;        return x&#10;    else:&#10;        return y&#10;&#10;&#10;def max3(x, y, z):&#10;    res1 = max2(x, y)&#10;    res2 = max2(res1, z)&#10;    return res2&#10;&#10;&#10;print(max3(11, 199, 2))&#10;2. 函数嵌套定义&#10;函数的嵌套定义指的是在函数内又定义了其他函数。&#10;&#10;# 示例1&#10;def func1():&#10;    print('from func1')&#10;&#10;    def func2():  # 定一个一个函数和定义一个变量类似&#10;        print('from func2')&#10;&#10;    print(func2)&#10;    func2()&#10;&#10;&#10;func1()&#10;# print(func2)&#10;&#10;&#10;# 示例2&#10;# 函数在定义阶段不执行函数体内的代码&#10;def f1():&#10;    print('f1')&#10;&#10;    def f2():&#10;        print('f2')&#10;&#10;        def f3():&#10;            print('f3')&#10;&#10;        f3()&#10;&#10;    f2()&#10;&#10;&#10;f1()&#10;二 名称空间&#10;1. 名称空间说明&#10;名称空间从字面意思理解是存放名字的地方，最开始我们在讲解变量的时候知道：定义一个变量就是开辟一块内存空间，这个内存空间存放的是变量的值，除了变量值之外，还有变量名，变量名与变量值的绑定关系这个数据要在内存中存储。变量名是名字，函数名也是名字，名称空间就是存放名字与值的绑定关系的地方。&#10;&#10;2. 名称空间的分类&#10;名称空间分为三类：&#10;&#10;内置名称空间：存放Python解释器自带的名字，在解释器启动时就生效，解释器关闭则失效。&#10;全局名称空间：文件级别的名字,在执行文件的时候生效，在文件结束或者在文件执行期间被删除则失效。有些全局名称空间可能一眼看上去不像是全局名称空间，我们只需要要记住，只要不是内置名称空间和局部名称空间，那么就是全局名称空间。&#10;局部名称空间：存放函数内定义的名字(函数的参数以及函数内的名字都存放与局部名称空间)，在函数调用时临时生效，函数结束则失效。&#10;# 内置&#10;print(print)&#10;print(len)&#10;&#10;# 以下4个都是全局&#10;&#10;x = 1  # 全局&#10;&#10;&#10;def func():  # func是全局名称空间&#10;    name = 'Albert'  # name是局部名称空间&#10;&#10;&#10;# del func  # 我们不需要自己删除&#10;&#10;&#10;if 10 &gt; 3:&#10;    y = 2  # 全局&#10;&#10;while True:&#10;    z = 5  # 全局&#10;    break&#10;&#10;&#10;# 局部&#10;def func1(x):  # 实参1传给行参x就相当于在函数内被定义 x=1，故x为局部&#10;    # x = 1&#10;    y = 2  # 局部&#10;&#10;&#10;func1(1)&#10;内置名称空间与全局名称空间的结束的生命周期基本上是一致的，程序执行结束或者文件关闭(手动强制关闭写python代码的这个文件)，内置或全局名称空间生命周期结束。局部名称空间生命周期是从函数调用开始到函数结束生命周期终止。&#10;&#10;加载顺序：内置名称空间-&gt;全局名称空间-&gt;局部名称空间&#10;查找名字：局部名称空间-&gt;全局名称空间-&gt;内置名称空间&#10;&#10;# 加载顺序很好理解，查找顺序是以当前位置为起始点&#10;&#10;len = 0  # 我们是为了测试，自己写代码千万不能覆盖内置名称空间&#10;&#10;&#10;def f1():&#10;    # len = 1&#10;&#10;    def f2():&#10;        # len = 2&#10;        print(len)&#10;&#10;    # len = 3&#10;    f2()&#10;&#10;&#10;f1()&#10;三 作用域&#10;1. 全局作用域&#10;全局作用域包含的是内置名称空间与全局名称空间的名字，它的特点是：&#10;&#10;在任何位置都能够访问的到&#10;该范围内的名字会伴随程序整个生命周期&#10;如果在局部使用全局作用域的变量，是没有问题的，但是如果是在局部修改全局作用域的变量则不能直接修改，而要使用global关键字才可以修改。&#10;&#10;global_count = 0&#10;&#10;&#10;def global_check():&#10;    print(global_count)  # 直接使用全局变量&#10;&#10;&#10;def global_modify():&#10;    global global_count  # 修改前需要先使用global&#10;    global_count += 1&#10;    print(global_count)&#10;&#10;&#10;global_check()&#10;global_modify()&#10;2. 局部作用域&#10;局部作用域包含的是局部名称空间的名字，它的特点是：&#10;&#10;只能在函数内使用&#10;调用函数时生效，调用结束失效&#10;如果在局部使用的是嵌套在函数内部的局部变量，同理，可以直接使用，而修改需要使用nonlocal关键字。&#10;&#10;def make_counter():&#10;    count = 0&#10;&#10;    def check_counter():&#10;        print(count)&#10;&#10;    check_counter()&#10;&#10;    def modify_counter():&#10;        nonlocal count&#10;        count += 1&#10;        print(count)&#10;&#10;    modify_counter()&#10;&#10;&#10;make_counter()&#10;四 函数对象&#10;1. 函数对象说明&#10;函数在Python中是第一类对象，这句话可以通俗理解为函数也是一个对象，就像是int，字符串，列表和字典一样都是对象，等讲到了面向对象我们就会对这个概念有了进一步理解，现在就可以暂时理解为函数对象可以像int或者字符串一样使用。&#10;&#10;# 1 函数可以被引用&#10;&#10;# int示例&#10;x = 1&#10;y = x&#10;&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;f = bar&#10;f()&#10;&#10;# 2 可以当中参数传入&#10;&#10;# int示例&#10;x = 1&#10;&#10;&#10;def func(a):&#10;    print(a)&#10;&#10;&#10;func(x)&#10;&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;def wrapper(func):&#10;    func()&#10;&#10;&#10;wrapper(bar)&#10;&#10;# 3 可以当中函数的返回值&#10;&#10;# int示例&#10;x = 1&#10;&#10;&#10;def foo():&#10;    return x&#10;&#10;&#10;res = foo()&#10;print(res)&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;def foo(func):&#10;    return func&#10;&#10;&#10;f = foo(bar)&#10;f()&#10;&#10;# 4 可以当中容器类型的元素&#10;&#10;# int示例&#10;z = 1&#10;l = [z, ]&#10;&#10;print(l)&#10;&#10;# 函数示例&#10;def get():&#10;    print('from get')&#10;&#10;&#10;def put():&#10;    print('from put')&#10;&#10;&#10;l1 = [get, put]&#10;&#10;l1[0]()&#10;2. 函数对象应用(重点)&#10;利用这一特性，可以优雅的取代原来的if多分支(elif这种多分支是我们写代码要尽可能避免的)。&#10;&#10;def auth():&#10;    print('登陆。。。。。')&#10;&#10;&#10;def register():&#10;    print('注册。。。。。')&#10;&#10;&#10;def check():&#10;    print('查看。。。。')&#10;&#10;&#10;def transfer():&#10;    print('转账。。。。')&#10;&#10;&#10;def pay():&#10;    print('支付。。。。')&#10;&#10;&#10;func_dict = {&#10;    '1': auth,&#10;    '2': register,&#10;    '3': check,&#10;    '4': transfer,&#10;    '5': pay&#10;}&#10;&#10;&#10;def interactive():&#10;    while True:&#10;        print(&quot;&quot;&quot;&#10;        1 登录&#10;        2 注册&#10;        3 查看&#10;        4 转账&#10;        5 支付&#10;        &quot;&quot;&quot;)&#10;        choice = input('&gt;&gt;: ').strip()&#10;        if choice in func_dict:&#10;            func_dict[choice]()&#10;        else:&#10;            print('非法操作')&#10;&#10;&#10;interactive()&#10;五 闭包函数&#10;1. 闭包函数说明&#10;闭包函数就是定义在函数内部的函数，也就是函数的嵌套定义，根据字面意思理解，闭包函数有两个关键字闭和包分别是的封闭和包裹。需要注意的重点是：闭包函数的作用域关系在函数定义阶段就固定死了，与调用位置无关。&#10;&#10;def outer():&#10;    x = 1&#10;&#10;    def inner():  # 在outer函数内部再定一个函数&#10;        # x = 2  &#10;        print('from inner', x)&#10;&#10;    return inner  # outer函数返回inner函数对象&#10;&#10;&#10;f = outer()  # 现在的f是一个全局变量，同时是inner函数对象&#10;print(f)&#10;x = 3  # 这个x = 3并不能改变inner函数外层的x&#10;f()&#10;&#10;&#10;def foo():&#10;    x = 4  # 这个x = 4 同样也不能改变&#10;    f()  # 全局作用域在任意位置都可以调用&#10;&#10;&#10;foo()&#10;闭包函数可以用外层函数来调用内部的函数，打破了函数的层级限制，与此同时该函数包含对外部函数作用域中名字的引用。&#10;&#10;def outer():&#10;    name = 'Albert'&#10;&#10;    def inner():&#10;        print('my name is %s' % name)&#10;&#10;    return inner&#10;&#10;&#10;f = outer()&#10;f()&#10;2. 为函数体传值的两种方式&#10;(1) 以参数的形式的传入&#10;# 模块的导入后面章节会讲解，requests模块就是模拟浏览器向目标站点发请求&#10;import requests&#10;&#10;&#10;def get(url):&#10;    response = requests.get(url)  # get方法获取请求返回对象&#10;    print(response)&#10;    if response.status_code == 200:  # 200是一个状态码，代表请求成功&#10;        print(response.text)  # text方法是获取返回对象的内容&#10;&#10;&#10;get('https://www.baidu.com')&#10;(2) 以闭包函数的形式传入&#10;闭包函数就是在函数外层再包裹一层作用域，由于这个作用域在外层函数内部，所以只作用在内层函数上。&#10;&#10;import requests&#10;&#10;&#10;def outer(url):  # 给外层函数穿参就相当于 url='https://www.baidu.com'&#10;&#10;    # url='https://www.baidu.com'  # 这个作用域就是作用在get函数上的&#10;    def get():&#10;        response = requests.get(url)&#10;        if response.status_code == 200:&#10;            print(response.text)&#10;&#10;    return get&#10;&#10;&#10;baidu = outer('https://www.baidu.com')&#10;python = outer('https://www.python.org')&#10;&#10;baidu()&#10;print('=================================&gt;')&#10;python()&#10;简化与总结闭包函数用法&#10;&#10;def outer(x):&#10;    def foo():  # foo虽然没有直接传参，但是outer函数的作用域赋予了x动态变化&#10;        print(x)&#10;&#10;    return foo&#10;&#10;&#10;f_10 = outer(10)&#10;&#10;f_10()&#10;&#10;f_100 = outer(100)&#10;f_100()&#10;六 装饰器&#10;1. 装饰器说明&#10;器指的工具(只要是工具，你就应该想到函数)，装饰指的是为被装饰对象添加新功能，需要注意的是：项目一旦上线之后，就应该遵循开发封闭的原则。开放封闭指的是对修改函数内的源代码和调用方式是封闭的，对功能的扩展是开放的。看起来有点矛盾，但这就是我们要做的。在这样的要求下，我们必须要找到一种解决方案，能够在不修改一个功能内源代码以及调用方式的前提下，为其添加新功能。这就用到了装饰器，它能够在不修改被装饰对象源代码与调用方式的前提下，为被装饰器对象添加新功能。&#10;&#10;2. 无参装饰器&#10;(1) 无参装饰器实现过程&#10;无参装饰器指的是装饰器本身没有参数。&#10;&#10;# 要求：为index函数添加一个统计时间的功能&#10;import time  # 这是一个与时间相关的模块&#10;&#10;&#10;def index():&#10;    time.sleep(3)  # 睡3秒&#10;    print('welcome to index page')&#10;&#10;&#10;index()&#10;&#10;# 版本一(只有index函数可以使用)&#10;import time  # 这是一个与时间相关的模块&#10;&#10;&#10;def index():&#10;    time.sleep(3)  # 睡3秒&#10;    print('welcome to index page')&#10;&#10;&#10;start_time = time.time()  # 从1970年开始计时的时间戳&#10;index()&#10;end_time = time.time()&#10;print('run time is %s' % (end_time - start_time))&#10;&#10;&#10;# 版本二(两个函数都可以使用，但是有大量重复代码)&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def home(name):&#10;    time.sleep(5)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;start_time = time.time()&#10;index()&#10;stop_time = time.time()&#10;print('run time is %s' % (stop_time - start_time))&#10;&#10;start_time = time.time()&#10;home('Albert')&#10;stop_time = time.time()&#10;print('run time is %s' % (stop_time - start_time))&#10;&#10;# 版本三(修改了源函数的调用方式)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def home(name):&#10;    time.sleep(5)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;def wrapper(func):  # func=index&#10;    start_time = time.time()&#10;    func()  # index()&#10;    stop_time = time.time()&#10;    print('run time is %s' % (stop_time - start_time))&#10;&#10;&#10;wrapper(index)&#10;&#10;# 版本四(使用闭包函数，不修改源函数调用方式)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def outer(func):  # func=最原始的index&#10;    # func=最原始的index&#10;    def wrapper():&#10;        start_time = time.time()&#10;        func()&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;&#10;    return wrapper&#10;&#10;&#10;# a = outer(index)  # outer函数结果可以赋值给任意变量&#10;# b = outer(index)&#10;# c = outer(index)&#10;&#10;index = outer(index)  # 赋值给index覆盖原来的index，index = wrapper&#10;&#10;index()  # wrapper()&#10;&#10;# 版本五(解决原函数返回值无效)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1  # 假如源函数有一个返回值&#10;&#10;&#10;def outer(func):&#10;    # func=最原始的home&#10;    def wrapper():&#10;        start_time = time.time()&#10;        res = func()  # 调用最原始的index&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;index = outer(index)  # 新的index=wrapper&#10;res = index()  # 上一个版本返回值为None&#10;print(res)&#10;&#10;# 版本六(终极版，解决有参函数和无参函数通用的问题)&#10;&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;def timer(func):  # 装饰器也是一个函数，我们给他一个好听的名字&#10;    def wrapper(*args, **kwargs):  # wrapper函数有无参数由源函数决定&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;index = timer(index)  # 新的index=wrapper&#10;home = timer(home)  # 新的home=wrapper&#10;&#10;home(name='Albert')  # wrapper(name='Albert')&#10;home('Albert')  # wrapper('Albert')&#10;index()  # wrapper()&#10;&#10;&#10;# 无参装饰器模板&#10;def outer(func):&#10;    def inner(*args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        这里写装饰器逻辑&#10;        :param args: 任意位置参数&#10;        :param kwargs: 任意关键参数&#10;        :return: 一个函数对象&#10;        &quot;&quot;&quot;&#10;        res = func(*args, **kwargs)&#10;        return res&#10;&#10;    return inner&#10;(2) 装饰器语法糖&#10;import time&#10;&#10;&#10;# 装饰器也是一个函数，使用函数必先定义，所以装饰器放在最上方&#10;def timer(func):&#10;    def wrapper(*args, **kwargs):&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;@timer  # 在被装饰对象正上方单独一行添加，相当于执行index=timer(index)&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;# @timer  # home=timer(home) 当不需要装饰器的时候只需注释这一行即可&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;index()&#10;home('Albert')&#10;(3) 用户认证装饰器&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(func):&#10;    def wrapper(*args, **kwargs):&#10;        if current_user['username']:&#10;            print('已经登陆过了')&#10;            res = func(*args, **kwargs)&#10;            return res&#10;&#10;        name = input('用户名&gt;&gt;: ').strip()&#10;        pwd = input('密码&gt;&gt;: ').strip()&#10;        if name == 'Albert' and pwd == '1':&#10;            print('登陆成功')&#10;            current_user['username'] = name&#10;            res = func(*args, **kwargs)&#10;            return res&#10;        else:&#10;            print('用户名或密码错误')&#10;&#10;    return wrapper&#10;&#10;&#10;@auth&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;@auth&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;index()&#10;home('Albert')&#10;(3) 多个装饰器叠加&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(func):&#10;    def wrapper(*args, **kwargs):&#10;        if current_user['username']:&#10;            print('已经登陆过了')&#10;            res = func(*args, **kwargs)&#10;            return res&#10;&#10;        name = input('用户名&gt;&gt;: ').strip()&#10;        pwd = input('密码&gt;&gt;: ').strip()&#10;        if name == 'Albert' and pwd == '1':&#10;            print('登陆成功')&#10;            current_user['username'] = name&#10;            res = func(*args, **kwargs)&#10;            return res&#10;        else:&#10;            print('用户名或密码错误')&#10;&#10;    return wrapper&#10;&#10;&#10;def timer(func):&#10;    def wrapper(*args, **kwargs):&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;&quot;&quot;&quot;&#10;@auth  &#10;@timer  # 这样写的话timer只统计index的执行时间&#10;&quot;&quot;&quot;&#10;&#10;&#10;@timer  # timer 统计的是auth+index的执行时间&#10;@auth&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;index()&#10;3. 有参装饰器&#10;有参装饰器就是装饰器本身需要一个参数，结合我们以前讲过的文件操作，其实文件就是存放数据的仓库，类似于数据库，数据库分很多种，常见的有MySQL，Oracle，PostgreSQL和DB2等等，在一些项目的需求中，不同的数据会分散存储在不同的数据库中，这时我们使用基于对象的数据模型(通俗讲就是使用编程语言来操作数据库)操作不同数据库就要执行不同的代码。&#10;&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(engine):&#10;    def user_auth(func):&#10;        def wrapper(*args, **kwargs):&#10;            if engine == 'file':&#10;                print('基于文件的认证')&#10;                if current_user['username']:&#10;                    print('已经登陆过了')&#10;                    res = func(*args, **kwargs)&#10;                    return res&#10;&#10;                name = input('用户名&gt;&gt;: ').strip()&#10;                pwd = input('密码&gt;&gt;: ').strip()&#10;                if name == 'Albert' and pwd == '1':&#10;                    print('登陆成功')&#10;                    current_user['username'] = name&#10;                    res = func(*args, **kwargs)&#10;                    return res&#10;                else:&#10;                    print('用户名或密码错误')&#10;            elif engine == 'mysql':&#10;                print('基于MyQL的认证')&#10;            elif engine == 'ldap':&#10;                print('基于LDAP的认证')&#10;            elif engine == 'postgresql':&#10;                print('基于PostgreSQL的认证')&#10;&#10;        return wrapper&#10;&#10;    return user_auth&#10;&#10;&#10;@auth('file')  # auth装饰器本身是一个函数，在语法糖中也可以传参数&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;index()&#10;4. 装饰器补充&#10;from functools import wraps&#10;&#10;&#10;def deco(func):&#10;    @wraps(func)  # 加在最内层函数正上方&#10;    def wrapper(*args, **kwargs):&#10;        return func(*args, **kwargs)&#10;&#10;    return wrapper&#10;&#10;&#10;@deco&#10;def index():&#10;    '''哈哈哈哈'''&#10;    print('from index')&#10;装饰器使用的是闭包函数的原理，返回的是和原来函数同名字的函数地址，再加上()就能调用这个函数，所以给我们的感觉是原来的函数没有变化，却添加了新的功能，其实已经不是原来的函数了，你可以把以上代码的第三行注释掉，运行代码，打印结果为None，就是因为你运行的函数已经不是原来的函数了，所以这其实是一个伪装饰器，要想让装饰器真的是装饰器，调用别人写好的包，返回结果还是原函数，以上写法就是。" />
    <option name="LAST_COMMIT_MESSAGE" value="闭包函数&#10;一 函数嵌套&#10;1. 函数嵌套调用&#10;函数嵌套调用指的是在函数内部又调用了其他的函数。&#10;&#10;#  求三个数的最大值&#10;def max2(x, y):&#10;    if x &gt; y:&#10;        return x&#10;    else:&#10;        return y&#10;&#10;&#10;def max3(x, y, z):&#10;    res1 = max2(x, y)&#10;    res2 = max2(res1, z)&#10;    return res2&#10;&#10;&#10;print(max3(11, 199, 2))&#10;2. 函数嵌套定义&#10;函数的嵌套定义指的是在函数内又定义了其他函数。&#10;&#10;# 示例1&#10;def func1():&#10;    print('from func1')&#10;&#10;    def func2():  # 定一个一个函数和定义一个变量类似&#10;        print('from func2')&#10;&#10;    print(func2)&#10;    func2()&#10;&#10;&#10;func1()&#10;# print(func2)&#10;&#10;&#10;# 示例2&#10;# 函数在定义阶段不执行函数体内的代码&#10;def f1():&#10;    print('f1')&#10;&#10;    def f2():&#10;        print('f2')&#10;&#10;        def f3():&#10;            print('f3')&#10;&#10;        f3()&#10;&#10;    f2()&#10;&#10;&#10;f1()&#10;二 名称空间&#10;1. 名称空间说明&#10;名称空间从字面意思理解是存放名字的地方，最开始我们在讲解变量的时候知道：定义一个变量就是开辟一块内存空间，这个内存空间存放的是变量的值，除了变量值之外，还有变量名，变量名与变量值的绑定关系这个数据要在内存中存储。变量名是名字，函数名也是名字，名称空间就是存放名字与值的绑定关系的地方。&#10;&#10;2. 名称空间的分类&#10;名称空间分为三类：&#10;&#10;内置名称空间：存放Python解释器自带的名字，在解释器启动时就生效，解释器关闭则失效。&#10;全局名称空间：文件级别的名字,在执行文件的时候生效，在文件结束或者在文件执行期间被删除则失效。有些全局名称空间可能一眼看上去不像是全局名称空间，我们只需要要记住，只要不是内置名称空间和局部名称空间，那么就是全局名称空间。&#10;局部名称空间：存放函数内定义的名字(函数的参数以及函数内的名字都存放与局部名称空间)，在函数调用时临时生效，函数结束则失效。&#10;# 内置&#10;print(print)&#10;print(len)&#10;&#10;# 以下4个都是全局&#10;&#10;x = 1  # 全局&#10;&#10;&#10;def func():  # func是全局名称空间&#10;    name = 'Albert'  # name是局部名称空间&#10;&#10;&#10;# del func  # 我们不需要自己删除&#10;&#10;&#10;if 10 &gt; 3:&#10;    y = 2  # 全局&#10;&#10;while True:&#10;    z = 5  # 全局&#10;    break&#10;&#10;&#10;# 局部&#10;def func1(x):  # 实参1传给行参x就相当于在函数内被定义 x=1，故x为局部&#10;    # x = 1&#10;    y = 2  # 局部&#10;&#10;&#10;func1(1)&#10;内置名称空间与全局名称空间的结束的生命周期基本上是一致的，程序执行结束或者文件关闭(手动强制关闭写python代码的这个文件)，内置或全局名称空间生命周期结束。局部名称空间生命周期是从函数调用开始到函数结束生命周期终止。&#10;&#10;加载顺序：内置名称空间-&gt;全局名称空间-&gt;局部名称空间&#10;查找名字：局部名称空间-&gt;全局名称空间-&gt;内置名称空间&#10;&#10;# 加载顺序很好理解，查找顺序是以当前位置为起始点&#10;&#10;len = 0  # 我们是为了测试，自己写代码千万不能覆盖内置名称空间&#10;&#10;&#10;def f1():&#10;    # len = 1&#10;&#10;    def f2():&#10;        # len = 2&#10;        print(len)&#10;&#10;    # len = 3&#10;    f2()&#10;&#10;&#10;f1()&#10;三 作用域&#10;1. 全局作用域&#10;全局作用域包含的是内置名称空间与全局名称空间的名字，它的特点是：&#10;&#10;在任何位置都能够访问的到&#10;该范围内的名字会伴随程序整个生命周期&#10;如果在局部使用全局作用域的变量，是没有问题的，但是如果是在局部修改全局作用域的变量则不能直接修改，而要使用global关键字才可以修改。&#10;&#10;global_count = 0&#10;&#10;&#10;def global_check():&#10;    print(global_count)  # 直接使用全局变量&#10;&#10;&#10;def global_modify():&#10;    global global_count  # 修改前需要先使用global&#10;    global_count += 1&#10;    print(global_count)&#10;&#10;&#10;global_check()&#10;global_modify()&#10;2. 局部作用域&#10;局部作用域包含的是局部名称空间的名字，它的特点是：&#10;&#10;只能在函数内使用&#10;调用函数时生效，调用结束失效&#10;如果在局部使用的是嵌套在函数内部的局部变量，同理，可以直接使用，而修改需要使用nonlocal关键字。&#10;&#10;def make_counter():&#10;    count = 0&#10;&#10;    def check_counter():&#10;        print(count)&#10;&#10;    check_counter()&#10;&#10;    def modify_counter():&#10;        nonlocal count&#10;        count += 1&#10;        print(count)&#10;&#10;    modify_counter()&#10;&#10;&#10;make_counter()&#10;四 函数对象&#10;1. 函数对象说明&#10;函数在Python中是第一类对象，这句话可以通俗理解为函数也是一个对象，就像是int，字符串，列表和字典一样都是对象，等讲到了面向对象我们就会对这个概念有了进一步理解，现在就可以暂时理解为函数对象可以像int或者字符串一样使用。&#10;&#10;# 1 函数可以被引用&#10;&#10;# int示例&#10;x = 1&#10;y = x&#10;&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;f = bar&#10;f()&#10;&#10;# 2 可以当中参数传入&#10;&#10;# int示例&#10;x = 1&#10;&#10;&#10;def func(a):&#10;    print(a)&#10;&#10;&#10;func(x)&#10;&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;def wrapper(func):&#10;    func()&#10;&#10;&#10;wrapper(bar)&#10;&#10;# 3 可以当中函数的返回值&#10;&#10;# int示例&#10;x = 1&#10;&#10;&#10;def foo():&#10;    return x&#10;&#10;&#10;res = foo()&#10;print(res)&#10;&#10;# 函数示例&#10;def bar():&#10;    print('from bar')&#10;&#10;&#10;def foo(func):&#10;    return func&#10;&#10;&#10;f = foo(bar)&#10;f()&#10;&#10;# 4 可以当中容器类型的元素&#10;&#10;# int示例&#10;z = 1&#10;l = [z, ]&#10;&#10;print(l)&#10;&#10;# 函数示例&#10;def get():&#10;    print('from get')&#10;&#10;&#10;def put():&#10;    print('from put')&#10;&#10;&#10;l1 = [get, put]&#10;&#10;l1[0]()&#10;2. 函数对象应用(重点)&#10;利用这一特性，可以优雅的取代原来的if多分支(elif这种多分支是我们写代码要尽可能避免的)。&#10;&#10;def auth():&#10;    print('登陆。。。。。')&#10;&#10;&#10;def register():&#10;    print('注册。。。。。')&#10;&#10;&#10;def check():&#10;    print('查看。。。。')&#10;&#10;&#10;def transfer():&#10;    print('转账。。。。')&#10;&#10;&#10;def pay():&#10;    print('支付。。。。')&#10;&#10;&#10;func_dict = {&#10;    '1': auth,&#10;    '2': register,&#10;    '3': check,&#10;    '4': transfer,&#10;    '5': pay&#10;}&#10;&#10;&#10;def interactive():&#10;    while True:&#10;        print(&quot;&quot;&quot;&#10;        1 登录&#10;        2 注册&#10;        3 查看&#10;        4 转账&#10;        5 支付&#10;        &quot;&quot;&quot;)&#10;        choice = input('&gt;&gt;: ').strip()&#10;        if choice in func_dict:&#10;            func_dict[choice]()&#10;        else:&#10;            print('非法操作')&#10;&#10;&#10;interactive()&#10;五 闭包函数&#10;1. 闭包函数说明&#10;闭包函数就是定义在函数内部的函数，也就是函数的嵌套定义，根据字面意思理解，闭包函数有两个关键字闭和包分别是的封闭和包裹。需要注意的重点是：闭包函数的作用域关系在函数定义阶段就固定死了，与调用位置无关。&#10;&#10;def outer():&#10;    x = 1&#10;&#10;    def inner():  # 在outer函数内部再定一个函数&#10;        # x = 2  &#10;        print('from inner', x)&#10;&#10;    return inner  # outer函数返回inner函数对象&#10;&#10;&#10;f = outer()  # 现在的f是一个全局变量，同时是inner函数对象&#10;print(f)&#10;x = 3  # 这个x = 3并不能改变inner函数外层的x&#10;f()&#10;&#10;&#10;def foo():&#10;    x = 4  # 这个x = 4 同样也不能改变&#10;    f()  # 全局作用域在任意位置都可以调用&#10;&#10;&#10;foo()&#10;闭包函数可以用外层函数来调用内部的函数，打破了函数的层级限制，与此同时该函数包含对外部函数作用域中名字的引用。&#10;&#10;def outer():&#10;    name = 'Albert'&#10;&#10;    def inner():&#10;        print('my name is %s' % name)&#10;&#10;    return inner&#10;&#10;&#10;f = outer()&#10;f()&#10;2. 为函数体传值的两种方式&#10;(1) 以参数的形式的传入&#10;# 模块的导入后面章节会讲解，requests模块就是模拟浏览器向目标站点发请求&#10;import requests&#10;&#10;&#10;def get(url):&#10;    response = requests.get(url)  # get方法获取请求返回对象&#10;    print(response)&#10;    if response.status_code == 200:  # 200是一个状态码，代表请求成功&#10;        print(response.text)  # text方法是获取返回对象的内容&#10;&#10;&#10;get('https://www.baidu.com')&#10;(2) 以闭包函数的形式传入&#10;闭包函数就是在函数外层再包裹一层作用域，由于这个作用域在外层函数内部，所以只作用在内层函数上。&#10;&#10;import requests&#10;&#10;&#10;def outer(url):  # 给外层函数穿参就相当于 url='https://www.baidu.com'&#10;&#10;    # url='https://www.baidu.com'  # 这个作用域就是作用在get函数上的&#10;    def get():&#10;        response = requests.get(url)&#10;        if response.status_code == 200:&#10;            print(response.text)&#10;&#10;    return get&#10;&#10;&#10;baidu = outer('https://www.baidu.com')&#10;python = outer('https://www.python.org')&#10;&#10;baidu()&#10;print('=================================&gt;')&#10;python()&#10;简化与总结闭包函数用法&#10;&#10;def outer(x):&#10;    def foo():  # foo虽然没有直接传参，但是outer函数的作用域赋予了x动态变化&#10;        print(x)&#10;&#10;    return foo&#10;&#10;&#10;f_10 = outer(10)&#10;&#10;f_10()&#10;&#10;f_100 = outer(100)&#10;f_100()&#10;六 装饰器&#10;1. 装饰器说明&#10;器指的工具(只要是工具，你就应该想到函数)，装饰指的是为被装饰对象添加新功能，需要注意的是：项目一旦上线之后，就应该遵循开发封闭的原则。开放封闭指的是对修改函数内的源代码和调用方式是封闭的，对功能的扩展是开放的。看起来有点矛盾，但这就是我们要做的。在这样的要求下，我们必须要找到一种解决方案，能够在不修改一个功能内源代码以及调用方式的前提下，为其添加新功能。这就用到了装饰器，它能够在不修改被装饰对象源代码与调用方式的前提下，为被装饰器对象添加新功能。&#10;&#10;2. 无参装饰器&#10;(1) 无参装饰器实现过程&#10;无参装饰器指的是装饰器本身没有参数。&#10;&#10;# 要求：为index函数添加一个统计时间的功能&#10;import time  # 这是一个与时间相关的模块&#10;&#10;&#10;def index():&#10;    time.sleep(3)  # 睡3秒&#10;    print('welcome to index page')&#10;&#10;&#10;index()&#10;&#10;# 版本一(只有index函数可以使用)&#10;import time  # 这是一个与时间相关的模块&#10;&#10;&#10;def index():&#10;    time.sleep(3)  # 睡3秒&#10;    print('welcome to index page')&#10;&#10;&#10;start_time = time.time()  # 从1970年开始计时的时间戳&#10;index()&#10;end_time = time.time()&#10;print('run time is %s' % (end_time - start_time))&#10;&#10;&#10;# 版本二(两个函数都可以使用，但是有大量重复代码)&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def home(name):&#10;    time.sleep(5)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;start_time = time.time()&#10;index()&#10;stop_time = time.time()&#10;print('run time is %s' % (stop_time - start_time))&#10;&#10;start_time = time.time()&#10;home('Albert')&#10;stop_time = time.time()&#10;print('run time is %s' % (stop_time - start_time))&#10;&#10;# 版本三(修改了源函数的调用方式)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def home(name):&#10;    time.sleep(5)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;def wrapper(func):  # func=index&#10;    start_time = time.time()&#10;    func()  # index()&#10;    stop_time = time.time()&#10;    print('run time is %s' % (stop_time - start_time))&#10;&#10;&#10;wrapper(index)&#10;&#10;# 版本四(使用闭包函数，不修改源函数调用方式)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(3)&#10;    print('welcome to index page')&#10;&#10;&#10;def outer(func):  # func=最原始的index&#10;    # func=最原始的index&#10;    def wrapper():&#10;        start_time = time.time()&#10;        func()&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;&#10;    return wrapper&#10;&#10;&#10;# a = outer(index)  # outer函数结果可以赋值给任意变量&#10;# b = outer(index)&#10;# c = outer(index)&#10;&#10;index = outer(index)  # 赋值给index覆盖原来的index，index = wrapper&#10;&#10;index()  # wrapper()&#10;&#10;# 版本五(解决原函数返回值无效)&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1  # 假如源函数有一个返回值&#10;&#10;&#10;def outer(func):&#10;    # func=最原始的home&#10;    def wrapper():&#10;        start_time = time.time()&#10;        res = func()  # 调用最原始的index&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;index = outer(index)  # 新的index=wrapper&#10;res = index()  # 上一个版本返回值为None&#10;print(res)&#10;&#10;# 版本六(终极版，解决有参函数和无参函数通用的问题)&#10;&#10;import time&#10;&#10;&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;def timer(func):  # 装饰器也是一个函数，我们给他一个好听的名字&#10;    def wrapper(*args, **kwargs):  # wrapper函数有无参数由源函数决定&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;index = timer(index)  # 新的index=wrapper&#10;home = timer(home)  # 新的home=wrapper&#10;&#10;home(name='Albert')  # wrapper(name='Albert')&#10;home('Albert')  # wrapper('Albert')&#10;index()  # wrapper()&#10;&#10;&#10;# 无参装饰器模板&#10;def outer(func):&#10;    def inner(*args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        这里写装饰器逻辑&#10;        :param args: 任意位置参数&#10;        :param kwargs: 任意关键参数&#10;        :return: 一个函数对象&#10;        &quot;&quot;&quot;&#10;        res = func(*args, **kwargs)&#10;        return res&#10;&#10;    return inner&#10;(2) 装饰器语法糖&#10;import time&#10;&#10;&#10;# 装饰器也是一个函数，使用函数必先定义，所以装饰器放在最上方&#10;def timer(func):&#10;    def wrapper(*args, **kwargs):&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;@timer  # 在被装饰对象正上方单独一行添加，相当于执行index=timer(index)&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;# @timer  # home=timer(home) 当不需要装饰器的时候只需注释这一行即可&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;index()&#10;home('Albert')&#10;(3) 用户认证装饰器&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(func):&#10;    def wrapper(*args, **kwargs):&#10;        if current_user['username']:&#10;            print('已经登陆过了')&#10;            res = func(*args, **kwargs)&#10;            return res&#10;&#10;        name = input('用户名&gt;&gt;: ').strip()&#10;        pwd = input('密码&gt;&gt;: ').strip()&#10;        if name == 'Albert' and pwd == '1':&#10;            print('登陆成功')&#10;            current_user['username'] = name&#10;            res = func(*args, **kwargs)&#10;            return res&#10;        else:&#10;            print('用户名或密码错误')&#10;&#10;    return wrapper&#10;&#10;&#10;@auth&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;@auth&#10;def home(name):&#10;    time.sleep(2)&#10;    print('welcome %s to home page' % name)&#10;&#10;&#10;index()&#10;home('Albert')&#10;(3) 多个装饰器叠加&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(func):&#10;    def wrapper(*args, **kwargs):&#10;        if current_user['username']:&#10;            print('已经登陆过了')&#10;            res = func(*args, **kwargs)&#10;            return res&#10;&#10;        name = input('用户名&gt;&gt;: ').strip()&#10;        pwd = input('密码&gt;&gt;: ').strip()&#10;        if name == 'Albert' and pwd == '1':&#10;            print('登陆成功')&#10;            current_user['username'] = name&#10;            res = func(*args, **kwargs)&#10;            return res&#10;        else:&#10;            print('用户名或密码错误')&#10;&#10;    return wrapper&#10;&#10;&#10;def timer(func):&#10;    def wrapper(*args, **kwargs):&#10;        start_time = time.time()&#10;        res = func(*args, **kwargs)&#10;        stop_time = time.time()&#10;        print(stop_time - start_time)&#10;        return res&#10;&#10;    return wrapper&#10;&#10;&#10;&quot;&quot;&quot;&#10;@auth  &#10;@timer  # 这样写的话timer只统计index的执行时间&#10;&quot;&quot;&quot;&#10;&#10;&#10;@timer  # timer 统计的是auth+index的执行时间&#10;@auth&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;index()&#10;3. 有参装饰器&#10;有参装饰器就是装饰器本身需要一个参数，结合我们以前讲过的文件操作，其实文件就是存放数据的仓库，类似于数据库，数据库分很多种，常见的有MySQL，Oracle，PostgreSQL和DB2等等，在一些项目的需求中，不同的数据会分散存储在不同的数据库中，这时我们使用基于对象的数据模型(通俗讲就是使用编程语言来操作数据库)操作不同数据库就要执行不同的代码。&#10;&#10;import time&#10;&#10;current_user = {&#10;    'username': None,&#10;}&#10;&#10;&#10;def auth(engine):&#10;    def user_auth(func):&#10;        def wrapper(*args, **kwargs):&#10;            if engine == 'file':&#10;                print('基于文件的认证')&#10;                if current_user['username']:&#10;                    print('已经登陆过了')&#10;                    res = func(*args, **kwargs)&#10;                    return res&#10;&#10;                name = input('用户名&gt;&gt;: ').strip()&#10;                pwd = input('密码&gt;&gt;: ').strip()&#10;                if name == 'Albert' and pwd == '1':&#10;                    print('登陆成功')&#10;                    current_user['username'] = name&#10;                    res = func(*args, **kwargs)&#10;                    return res&#10;                else:&#10;                    print('用户名或密码错误')&#10;            elif engine == 'mysql':&#10;                print('基于MyQL的认证')&#10;            elif engine == 'ldap':&#10;                print('基于LDAP的认证')&#10;            elif engine == 'postgresql':&#10;                print('基于PostgreSQL的认证')&#10;&#10;        return wrapper&#10;&#10;    return user_auth&#10;&#10;&#10;@auth('file')  # auth装饰器本身是一个函数，在语法糖中也可以传参数&#10;def index():&#10;    time.sleep(1)&#10;    print('welcome to index page')&#10;    return 1&#10;&#10;&#10;index()&#10;4. 装饰器补充&#10;from functools import wraps&#10;&#10;&#10;def deco(func):&#10;    @wraps(func)  # 加在最内层函数正上方&#10;    def wrapper(*args, **kwargs):&#10;        return func(*args, **kwargs)&#10;&#10;    return wrapper&#10;&#10;&#10;@deco&#10;def index():&#10;    '''哈哈哈哈'''&#10;    print('from index')&#10;装饰器使用的是闭包函数的原理，返回的是和原来函数同名字的函数地址，再加上()就能调用这个函数，所以给我们的感觉是原来的函数没有变化，却添加了新的功能，其实已经不是原来的函数了，你可以把以上代码的第三行注释掉，运行代码，打印结果为None，就是因为你运行的函数已经不是原来的函数了，所以这其实是一个伪装饰器，要想让装饰器真的是装饰器，调用别人写好的包，返回结果还是原函数，以上写法就是。" />
  </component>
  <component name="com.intellij.coverage.CoverageDataManagerImpl">
    <SUITE FILE_PATH="coverage/python_learn$Day_09.coverage" NAME="Day_09 Coverage Results" MODIFIED="1555775289175" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Day_09" />
    <SUITE FILE_PATH="coverage/python_learn$have_a_try.coverage" NAME="have a try Coverage Results" MODIFIED="1555772839892" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Day_09" />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/Day_09/have a try.py">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="76">
          <caret line="5" selection-start-line="5" selection-end-line="26" selection-end-column="14" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/Day_09/Day_09.py">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="142">
          <caret line="140" column="8" selection-start-line="140" selection-start-column="8" selection-end-line="140" selection-end-column="34" />
        </state>
      </provider>
    </entry>
  </component>
</project>